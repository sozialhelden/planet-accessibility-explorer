{"version":3,"sources":["components/core/BlueprintDarkModeContainer.tsx","components/core/composeContexts.tsx","components/OverflowScrollContainer.tsx","components/map/FeatureDetails.tsx","components/map/FeatureListPopup.tsx","components/map/filterLayers.tsx","components/map/useMapStyle.tsx","components/map/MapView.tsx","components/map/getFeatureIdsFromLocation.ts","components/App.tsx","components/hooks/useGlobalHotkeys.tsx","reportWebVitals.ts","index.tsx"],"names":["getDarkModeSetting","window","matchMedia","matches","BlueprintDarkModeContainer","props","isDarkMode","React","setIsDarkMode","handleChange","e","undefined","addEventListener","useDarkMode","className","children","composeContexts","contextAndValuePairs","reduce","acc","Context","value","Provider","OverflowScrollContainer","styled","div","fetcher","input","init","fetch","then","res","json","Skeleton","FeatureDetails","featureId","url","source","id","data","error","useSWR","intent","JSON","stringify","sortedKeys","Object","keys","properties","sort","a","b","startsWith","map","k","FeatureListPopup","featureIds","content","LIST_UNSTYLED","latitude","longitude","closeButton","closeOnClick","onClose","anchor","databaseTableNames","useMapStyle","process","loading","ZoomToDataOnLoad","MapContext","MapView","containerRef","width","height","useMeasure","mapRef","useRef","viewport","setViewport","useState","zoom","useLayoutEffect","newViewport","history","useHistory","location","useLocation","match","pathname","featureIdString","uniq","split","s","getFeatureIdsFromLocation","query","URLSearchParams","search","get","handleMapClick","useCallback","event","console","log","features","length","push","f","join","lngLat","closePopup","setViewportCallback","viewState","interactionState","mapStyle","layers","filter","layer","find","tableName","filterLayers","ref","style","flex","display","visible","position","mapboxApiAccessToken","onViewportChange","interactiveLayerIds","onClick","name","type","tiles","Number","parseFloat","mapboxgl","workerClass","require","default","FocusStyleManager","onlyShowFocusOnTabs","AppBody","App","contexts","onSelectFeature","_id","mapView","navbarAndBody","hotkeys","useMemo","combo","global","label","onKeyDown","alert","allowInInput","preventDefault","handleKeyDown","handleKeyUp","flexDirection","onKeyUp","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","dotenv","config","enableAllPlugins","enablePatches","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.0dd18b31.chunk.js","sourcesContent":["import { HTMLDivProps } from \"@blueprintjs/core\";\nimport * as React from \"react\";\n\nfunction getDarkModeSetting(): boolean {\n  return (\n    window.matchMedia &&\n    window.matchMedia(\"(prefers-color-scheme: dark)\").matches\n  );\n}\n\n/**\n * A React Hook returning a boolean value that is `true` when the user switched on dark mode,\n * `false` otherwise.\n */\nexport function useDarkMode() {\n  const [isDarkMode, setIsDarkMode] = React.useState(getDarkModeSetting());\n\n  const handleChange = React.useCallback((e) => {\n    setIsDarkMode(getDarkModeSetting());\n  }, []);\n\n  React.useEffect(() => {\n    if (window.matchMedia === undefined) {\n      return;\n    }\n    window\n      .matchMedia(\"(prefers-color-scheme: dark)\")\n      .addEventListener(\"change\", handleChange);\n  }, [handleChange]);\n\n  return isDarkMode;\n}\n\n/**\n * A React component wrapper with a Blueprint CSS class that controls if the container's children\n * are rendered in dark-mode style or not.\n *\n * Wrap your Blueprint.js components in this React component to adapt them to the user's dark mode\n * setting automatically.\n */\nexport default function BlueprintDarkModeContainer(props: HTMLDivProps) {\n  const isDarkMode = useDarkMode();\n  return (\n    <div\n      {...props}\n      className={isDarkMode ? `${props.className} bp3-dark` : props.className}\n    >\n      {props.children}\n    </div>\n  );\n}\n","export type ContextAndValue<T> = [React.Context<T>, T];\n\n/**\n * This function allows you to render a React component with multiple nested React contexts around\n * it, but makes the code doing that more readable.\n *\n * @param contextAndValuePairs an array of [context ref, context value] entries.\n * @param children the react children to render.\n * @example\n * ```jsx\n * const contexts: ContextAndValue<any>[] = [\n *    [SomeContext, someValue],\n *    [UndoContext, undoContext]\n * ];\n * return <div>\n *   {composeContexts(contexts, navbarAndBody)}\n * </div>;\n * ```\n */\n\nconst composeContexts = (\n  contextAndValuePairs: ContextAndValue<any>[],\n  children: React.ReactNode\n) =>\n  contextAndValuePairs.reduce(\n    (acc: React.ReactNode, [Context, value]: ContextAndValue<any>) => {\n      return <Context.Provider value={value}>{acc}</Context.Provider>;\n    },\n    children\n  );\n\nexport default composeContexts;\n","import styled from \"styled-components\";\n\nconst OverflowScrollContainer = styled.div`\n  overflow: auto;\n`;\n\nexport default OverflowScrollContainer;\n","import { Callout } from \"@blueprintjs/core\";\nimport React from \"react\";\nimport useSWR from \"swr\";\nimport Feature, { FeatureId } from \"../../model/Feature\";\n\ntype Props = {\n  featureId: FeatureId;\n};\n\nconst fetcher = (input: RequestInfo, init?: RequestInit | undefined) =>\n  fetch(input, init).then((res) => res.json());\n\nfunction Skeleton() {\n  return <div className=\"bp3-skeleton\">Loading...</div>;\n}\n\nexport default function FeatureDetails(props: Props) {\n  const { featureId } = props;\n  const url = `${process.env.REACT_APP_OSM_API_BACKEND_URL}/${featureId.source}/${featureId.id}.json`;\n\n  const { data, error } = useSWR<Feature, { error: any }>(url, fetcher);\n\n  if (error) return <Callout intent=\"danger\">{JSON.stringify(error)}</Callout>;\n\n  if (!data) return <Skeleton />;\n\n  const sortedKeys = Object.keys(data.properties)\n    .sort()\n    .sort((a, b) => {\n      if (b.startsWith(\"name\")) return -1;\n      if (a.startsWith(\"name\")) return 1;\n      return 0;\n    });\n\n  return (\n    <>\n      <h2>\n        {featureId.source} / {featureId.id}\n      </h2>\n      <table>\n        {sortedKeys.map((k) => (\n          <tr key={k}>\n            <th>{k}</th>\n            <td>{data.properties[k]}</td>\n          </tr>\n        ))}\n      </table>\n    </>\n  );\n}\n","import { UL } from \"@blueprintjs/core\";\nimport { LIST_UNSTYLED } from \"@blueprintjs/core/lib/esm/common/classes\";\nimport React from \"react\";\nimport { Popup } from \"react-map-gl\";\nimport { FeatureId } from \"../../model/Feature\";\nimport FeatureDetails from \"./FeatureDetails\";\n\ntype Props = {\n  featureIds: FeatureId[];\n  latitude: number;\n  longitude: number;\n  onClose?: () => void;\n};\n\nexport default function FeatureListPopup(props: Props) {\n  const { featureIds } = props;\n  const content = (\n    <UL>\n      {featureIds.map((featureId) => (\n        <li\n          className={LIST_UNSTYLED}\n          key={`${featureId.source}/${featureId.id}`}\n        >\n          <FeatureDetails featureId={featureId} />\n        </li>\n      ))}\n    </UL>\n  );\n\n  return (\n    <Popup\n      latitude={props.latitude}\n      longitude={props.longitude}\n      closeButton={true}\n      closeOnClick={false}\n      onClose={props.onClose}\n      anchor=\"top\"\n    >\n      {content}\n    </Popup>\n  );\n}\n","export const databaseTableNames = [\n  \"admin\",\n  \"places\",\n  \"amenities\",\n  \"entrances_or_exits\",\n  \"elevators\",\n  \"ramps\",\n  \"pedestrian_highways\",\n  \"conveying\",\n  \"toilets\",\n  \"buildings\",\n  \"master_routes\",\n  \"master_route_members\",\n  \"routes\",\n  \"route_members\",\n  \"stop_areas\",\n  \"stop_area_members\",\n  \"platforms\",\n  \"stop_positions\",\n  \"stations\",\n];\n\n/**\n * Filter layers from a mapbox-gl stylesheet.\n *\n * Keep only layers that have an `id` matching a 'osm-' prefix, and change sources to match the\n * table names from our OSM database.\n *\n * @param layers The layers to filter\n */\nexport function filterLayers(layers: mapboxgl.Layer[]): mapboxgl.Layer[] {\n  return layers\n    .filter((layer) => layer.id?.startsWith(\"osm-\"))\n    .map((layer) => {\n      // In Mapbox Studio, layers have a source layer reference that uses a random string ID like\n      // 'entrances_or_exits_saarbrueck-0vxz2q'. We need to replace that with the actual table name,\n      // for example 'entrances_or_exits'.\n      const source = databaseTableNames.find((tableName) =>\n        layer[\"source-layer\"]?.startsWith(tableName)\n      );\n\n      return {\n        ...layer,\n        source,\n        \"source-layer\": \"default\",\n      };\n    })\n    .filter((layer) => layer.source);\n}\n","import useSWR from \"swr\";\n\nconst fetcher = (input: RequestInfo, init?: RequestInit | undefined) =>\n  fetch(input, init).then((res) => res.json());\n\nfunction useMapStyle() {\n  const styleId = process.env.REACT_APP_MAPBOX_STYLE_ID;\n  const accessToken = process.env.REACT_APP_MAPBOX_ACCESS_TOKEN;\n  const accountId = process.env.REACT_APP_MAPBOX_ACCOUNT_ID;\n\n  const url = `https://api.mapbox.com/styles/v1/${accountId}/${styleId}?fresh=true&access_token=${accessToken}`;\n\n  const { data, error } = useSWR<mapboxgl.Style, { error: any }>(url, fetcher);\n\n  if (error) return { error };\n  if (!data) return { loading: true };\n\n  return { data };\n}\n\nexport default useMapStyle;\n","import mapboxgl from \"mapbox-gl\";\nimport * as React from \"react\";\nimport { useCallback, useLayoutEffect, useRef, useState } from \"react\";\nimport ReactMapGL, {\n  Layer,\n  MapContext,\n  MapEvent,\n  MapRef,\n  Source,\n  ViewportProps,\n} from \"react-map-gl\";\nimport \"react-map-gl-geocoder/dist/mapbox-gl-geocoder.css\";\nimport { useHistory, useLocation } from \"react-router\";\nimport useMeasure from \"react-use-measure\";\nimport OverflowScrollContainer from \"../OverflowScrollContainer\";\nimport FeatureListPopup from \"./FeatureListPopup\";\nimport { databaseTableNames, filterLayers } from \"./filterLayers\";\nimport getFeatureIdsFromLocation from \"./getFeatureIdsFromLocation\";\nimport useMapStyle from \"./useMapStyle\";\n\n// The following is required to stop \"npm build\" from transpiling mapbox code.\n// notice the exclamation point in the import.\n// @ts-ignore\n// eslint-disable-next-line import/no-webpack-loader-syntax, import/no-unresolved\nmapboxgl.workerClass = require(\"worker-loader!mapbox-gl/dist/mapbox-gl-csp-worker\").default;\n\ninterface IProps {\n  featureId?: string;\n  onSelectFeature: (_id: string) => void;\n  className?: string;\n  timestamp?: number;\n  visible?: boolean;\n  children?: React.ReactNode;\n}\n\nfunction ZoomToDataOnLoad() {\n  const mapContext = React.useContext(MapContext);\n\n  if (mapContext.map) {\n    // do something\n  }\n  return null;\n}\n\nexport default function MapView(props: IProps) {\n  const [containerRef, { width, height }] = useMeasure();\n  const mapRef = useRef<MapRef>(null);\n\n  const [viewport, setViewport] = useState<\n    Partial<ViewportProps> & { width: number; height: number }\n  >({\n    width: 100,\n    height: 100,\n    latitude: 52.5,\n    longitude: 13.3,\n    zoom: 10,\n  });\n\n  // Pan to feature boundary if no single feature is selected and the source is loaded for the first time\n  // useEffect(() => {\n  //   if (feature) {\n  //     return;\n  //   }\n\n  //   const map = mapRef.current?.getMap() as Map;\n  //   if (!map) {\n  //     return;\n  //   }\n\n  //   map.once('idle', () => {\n  //     const features = map.querySourceFeatures('features');\n  //     const bounds = new LngLatBounds();\n  //     features\n  //       .filter(f => f.geometry?.coordinates)\n  //       .forEach(feature => bounds.extend(feature.geometry.coordinates));\n  //     if (bounds.isEmpty()) {\n  //       return;\n  //     }\n  //     const northWest = bounds.getNorthWest();\n  //     const southEast = bounds.getSouthEast();\n  //     if (!northWest || !southEast) {\n  //       return;\n  //     }\n  //     if (northWest.distanceTo(southEast) === 0) {\n  //       map.setCenter(bounds.getNorthEast());\n  //     } else {\n  //       map.fitBounds(bounds.toArray() as LngLatBoundsLike, { padding: 100, maxDuration: 0 });\n  //     }\n  //     map.once('idle', () => {\n  //       const newMapCenter = map.getCenter();\n  //       setViewport({ ...viewport, zoom: map.getZoom(), latitude: newMapCenter.lat, longitude: newMapCenter.lng });\n  //     });\n  //   });\n\n  //   // const newViewport = {\n  //   //   ...viewport,\n  //   //   latitude: feature?.geometry.coordinates?.[1],\n  //   //   longitude: feature?.geometry.coordinates?.[0],\n  //   //   zoom: Math.max(10, viewport.zoom || 10),\n  //   // };\n\n  //   // setViewport(newViewport);\n  // }, [mapRef.current]);\n\n  // Pan to single selected map feature, if it exists or changes\n  // useEffect(() => {\n  //   if (!feature || !feature.geometry) {\n  //     return;\n  //   }\n\n  //   const map = mapRef.current?.getMap() as Map;\n  //   if (!map) {\n  //     return;\n  //   }\n  //   const bounds = map.getBounds();\n  //   if (\n  //     viewport?.zoom &&\n  //     viewport?.zoom >= 10 &&\n  //     bounds &&\n  //     bounds.contains(feature.geometry.coordinates)\n  //   ) {\n  //     return;\n  //   }\n\n  //   const newViewport = {\n  //     ...viewport,\n  //     latitude: feature?.geometry.coordinates?.[1],\n  //     longitude: feature?.geometry.coordinates?.[0],\n  //     zoom: Math.max(10, viewport.zoom || 10),\n  //     pitch: 50,\n  //   };\n\n  //   setViewport(newViewport);\n  // }, [mapRef.current, feature?.geometry?.coordinates[0], feature?.geometry?.coordinates[1]]);\n\n  // Reset viewport when map size changes\n  useLayoutEffect(() => {\n    const newViewport = { ...viewport, width, height };\n    setViewport(newViewport);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [width, height]);\n\n  const history = useHistory();\n\n  const location = useLocation();\n  const featureIds = getFeatureIdsFromLocation(location);\n  const query = new URLSearchParams(location.search);\n  const latitude = query.get(\"lat\");\n  const longitude = query.get(\"lon\");\n\n  // const featureLayer = useMemo(() => {\n  //   return generateSelectedFeatureLayer(props.featureId);\n  // }, [props.featureId]);\n\n  // const featureDetailsLayer = useMemo(() => {\n  //   return generateFeatureDetailsLayer(props.featureId);\n  // }, [props.featureId]);\n\n  // const unclusteredPointLabelLayer = useMemo(() => {\n  //   return generateUnclusteredPointLabelLayer(lastImportType, languageTagsStrings, props.featureId);\n  // }, [lastImportType, props.featureId]);\n\n  const handleMapClick = useCallback<(event: MapEvent) => void>(\n    (event) => {\n      console.log(event);\n      if (event?.features?.length) {\n        // Show source overview again if user just clicks/taps on the map\n        history.push(\n          `/composite/${event.features\n            .map((f) => [f.source, f.properties.id].join(\":\"))\n            .join(\",\")}?lon=${event.lngLat[0]}&lat=${event.lngLat[1]}`\n        );\n        return;\n      }\n\n      history.push(\"/\");\n      // if (feature?.layer.id === featureLayer.id) {\n      //   // Selected a single point\n      //   props.onSelectFeature(feature.properties._id || feature._id);\n      // }\n    },\n    [history]\n  );\n\n  const closePopup = useCallback(() => {\n    history.push(`/`);\n  }, [history]);\n\n  const setViewportCallback = useCallback(\n    (viewState, interactionState) => {\n      // console.log('Setting viewport because of callback:', viewState, interactionState);\n      setViewport({ ...viewport, ...viewState });\n    },\n    [setViewport, viewport]\n  );\n\n  // const onLoadCallback = useCallback(() => {\n  // const map = mapRef.current?.getMap();\n  // }, [mapRef.current]);\n\n  const mapStyle = useMapStyle();\n  const layers = React.useMemo(\n    () => mapStyle.data?.layers && filterLayers(mapStyle.data?.layers),\n    [mapStyle]\n  );\n\n  return (\n    // Container needs to hide overflow because it's used for measurement.\n    // Without hiding overflowing content, it would adapt its own size to its overflowing content\n    // size on reducing its size while resizing the viewport, so it would only grow bigger, never\n    // shrink.\n    <OverflowScrollContainer\n      ref={containerRef}\n      className={props.className}\n      style={{\n        flex: 1,\n        display: props.visible === false ? \"none\" : \"block\",\n        position: \"relative\",\n      }}\n    >\n      <ReactMapGL\n        {...viewport}\n        mapboxApiAccessToken={process.env.REACT_APP_MAPBOX_ACCESS_TOKEN}\n        onViewportChange={setViewportCallback}\n        interactiveLayerIds={[\n          \"osm-entrance-icon\",\n          \"osm-toilet\",\n          \"osm-surface-outline\",\n          \"osm-surface-fill\",\n          \"osm-poi-wheelchair-circle\",\n          \"osm-wheelchair-yes-label\",\n          \"osm-wheelchair-no-label\",\n          \"osm-wheelchair-limited-label\",\n          \"osm-pedestrian-highways-wheelchair-outline\",\n          \"osm-building-wheelchair-outline\",\n        ]}\n        onClick={handleMapClick}\n        // onLoad={onLoadCallback}\n        mapStyle=\"mapbox://styles/mapbox/light-v10\"\n        // mapStyle={null}\n        ref={mapRef}\n      >\n        {databaseTableNames.map((name) => (\n          <Source\n            type=\"vector\"\n            tiles={[\n              `${process.env.REACT_APP_OSM_API_BACKEND_URL}/${name}.mvt?limit=10000&bbox={bbox-epsg-3857}&epsg=3857`,\n            ]}\n            id={name}\n            key={name}\n          />\n        ))}\n        {layers?.map((layer) => (\n          <Layer key={layer.id} {...(layer as any)} />\n        ))}\n        {latitude && longitude && featureIds.length > 0 && (\n          <FeatureListPopup\n            featureIds={featureIds}\n            latitude={Number.parseFloat(latitude)}\n            longitude={Number.parseFloat(longitude)}\n            onClose={closePopup}\n          />\n        )}\n        <ZoomToDataOnLoad />\n      </ReactMapGL>\n      {props.children}\n    </OverflowScrollContainer>\n  );\n}\n","import { Location } from \"history\";\nimport { uniq } from \"lodash\";\nimport { FeatureId } from \"../../model/Feature\";\n\nexport default function useFeatureIdsFromLocation(location: Location) {\n  const match = location.pathname.match(/^\\/(\\w+)\\/([\\w,:-]+)/);\n  let featureIds: FeatureId[] = [];\n  if (match && typeof match[1] === \"string\" && typeof match[2] === \"string\") {\n    const featureIdString = match[2];\n    if (match[1] === \"composite\") {\n      const components = uniq(featureIdString.split(\",\").sort());\n      featureIds = components.map((s) => {\n        const [source, id] = s.split(\":\");\n        return { source, id };\n      });\n    } else {\n      featureIds = [{ source: match[1], id: featureIdString }];\n    }\n  }\n  return featureIds;\n}\n","import {\n  FocusStyleManager,\n  HotkeysProvider,\n  HotkeysTarget2,\n} from \"@blueprintjs/core\";\nimport * as React from \"react\";\nimport { useHistory, useLocation } from \"react-router\";\nimport styled from \"styled-components\";\nimport \"./App.css\";\nimport BlueprintDarkModeContainer from \"./core/BlueprintDarkModeContainer\";\nimport composeContexts, { ContextAndValue } from \"./core/composeContexts\";\nimport { useGlobalHotkeys } from \"./hooks/useGlobalHotkeys\";\nimport { Legend } from \"./Legend\";\nimport MapView from \"./map/MapView\";\nimport OverflowScrollContainer from \"./OverflowScrollContainer\";\n\nFocusStyleManager.onlyShowFocusOnTabs();\n\nconst AppBody = styled.div`\n  flex: 1;\n  overflow: hidden;\n  display: flex;\n  flex-direction: row;\n  align-items: stretch;\n`;\n\nfunction App() {\n  // const { viewMenuButton, viewOptions } = useViewOptionsButton();\n  // const isDarkMode = useDarkMode();\n  // The panel showing the Linked Data vocabulary graph\n\n  const contexts: ContextAndValue<any>[] = [\n    // [RDFGraphContext, rdfStore],\n  ];\n  const history = useHistory();\n  const location = useLocation();\n\n  const onSelectFeature = React.useCallback<(_id: string) => void>(\n    (_id) => {\n      const url = `/features/${_id}`;\n      history.push(`${url}${location.search}`);\n    },\n    [history, location]\n  );\n\n  const sidebar = (\n    <OverflowScrollContainer\n      style={{ width: \"400px\", padding: \"1rem\", margin: \"0\" }}\n    >\n      <h1>Miki: Erforsche deinen Kiez</h1>\n      <Legend />\n    </OverflowScrollContainer>\n  );\n\n  const mapView = (\n    <MapView\n      featureId={undefined}\n      onSelectFeature={onSelectFeature}\n      visible={true}\n    />\n  );\n\n  const navbarAndBody = (\n    <>\n      <AppBody>\n        {/* {sidebar} */}\n        {mapView}\n      </AppBody>\n    </>\n  );\n\n  const hotkeys = useGlobalHotkeys();\n  return (\n    <HotkeysProvider>\n      <HotkeysTarget2 hotkeys={hotkeys}>\n        {({ handleKeyDown, handleKeyUp }) => (\n          <BlueprintDarkModeContainer\n            style={{\n              height: \"100%\",\n              display: \"flex\",\n              flexDirection: \"column\",\n            }}\n            onKeyDown={handleKeyDown}\n            onKeyUp={handleKeyUp}\n          >\n            {composeContexts(contexts, navbarAndBody)}\n          </BlueprintDarkModeContainer>\n        )}\n      </HotkeysTarget2>\n    </HotkeysProvider>\n  );\n}\n\nexport default App;\n","import React from \"react\";\n\nexport function useGlobalHotkeys() {\n  return React.useMemo(\n    () => [\n      {\n        combo: \"mod+z\",\n        global: true,\n        label: \"Undo\",\n        onKeyDown: () => {\n          alert(\"!!\");\n        },\n        allowInInput: false,\n        preventDefault: true,\n      },\n      {\n        global: true,\n        combo: \"mod+shift+z\",\n        label: \"Redo\",\n        onKeyDown: () => {\n          alert(\"!!\");\n        },\n        allowInInput: false,\n        preventDefault: true,\n      },\n    ],\n    []\n  );\n}\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import dotenv from \"dotenv\";\nimport { enableAllPlugins, enablePatches } from \"immer\";\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { BrowserRouter } from \"react-router-dom\";\nimport App from \"./components/App\";\nimport \"./index.css\";\nimport reportWebVitals from \"./reportWebVitals\";\n\ndotenv.config();\nenableAllPlugins();\nenablePatches();\n\nReactDOM.render(\n  <React.StrictMode>\n    <BrowserRouter>\n      <App />\n    </BrowserRouter>\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}