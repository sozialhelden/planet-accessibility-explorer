{"version":3,"sources":["components/core/BlueprintDarkModeContainer.tsx","components/core/composeContexts.tsx","components/OverflowScrollContainer.tsx","components/map/filterLayers.tsx","components/map/useMapStyle.tsx","components/map/MapView.tsx","components/App.tsx","components/hooks/useGlobalHotkeys.tsx","reportWebVitals.ts","index.tsx"],"names":["getDarkModeSetting","window","matchMedia","matches","BlueprintDarkModeContainer","props","isDarkMode","React","setIsDarkMode","handleChange","e","undefined","addEventListener","useDarkMode","className","children","composeContexts","contextAndValuePairs","reduce","acc","Context","value","Provider","OverflowScrollContainer","styled","div","databaseTableNames","fetcher","input","init","fetch","then","res","json","useMapStyle","url","process","useSWR","data","error","loading","ZoomToDataOnLoad","MapContext","map","MapView","containerRef","width","height","useMeasure","mapRef","useRef","viewport","setViewport","useState","latitude","longitude","zoom","useLayoutEffect","newViewport","history","useHistory","handleMapClick","useCallback","event","features","push","setViewportCallback","viewState","interactionState","onLoadCallback","current","mapStyle","layers","filter","layer","id","startsWith","source","find","tableName","filterLayers","ref","style","flex","display","visible","position","mapboxApiAccessToken","onViewportChange","onClick","onLoad","name","type","tiles","mapboxgl","workerClass","require","default","FocusStyleManager","onlyShowFocusOnTabs","AppBody","App","contexts","location","useLocation","onSelectFeature","_id","search","mapView","featureId","navbarAndBody","hotkeys","useMemo","combo","global","label","onKeyDown","alert","allowInInput","preventDefault","handleKeyDown","handleKeyUp","flexDirection","onKeyUp","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","dotenv","config","enableAllPlugins","enablePatches","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.af61a824.chunk.js","sourcesContent":["import { HTMLDivProps } from \"@blueprintjs/core\";\nimport * as React from \"react\";\n\nfunction getDarkModeSetting(): boolean {\n  return (\n    window.matchMedia &&\n    window.matchMedia(\"(prefers-color-scheme: dark)\").matches\n  );\n}\n\n/**\n * A React Hook returning a boolean value that is `true` when the user switched on dark mode,\n * `false` otherwise.\n */\nexport function useDarkMode() {\n  const [isDarkMode, setIsDarkMode] = React.useState(getDarkModeSetting());\n\n  const handleChange = React.useCallback((e) => {\n    setIsDarkMode(getDarkModeSetting());\n  }, []);\n\n  React.useEffect(() => {\n    if (window.matchMedia === undefined) {\n      return;\n    }\n    window\n      .matchMedia(\"(prefers-color-scheme: dark)\")\n      .addEventListener(\"change\", handleChange);\n  }, [handleChange]);\n\n  return isDarkMode;\n}\n\n/**\n * A React component wrapper with a Blueprint CSS class that controls if the container's children\n * are rendered in dark-mode style or not.\n *\n * Wrap your Blueprint.js components in this React component to adapt them to the user's dark mode\n * setting automatically.\n */\nexport default function BlueprintDarkModeContainer(props: HTMLDivProps) {\n  const isDarkMode = useDarkMode();\n  return (\n    <div\n      {...props}\n      className={isDarkMode ? `${props.className} bp3-dark` : props.className}\n    >\n      {props.children}\n    </div>\n  );\n}\n","export type ContextAndValue<T> = [React.Context<T>, T];\n\n/**\n * This function allows you to render a React component with multiple nested React contexts around\n * it, but makes the code doing that more readable.\n *\n * @param contextAndValuePairs an array of [context ref, context value] entries.\n * @param children the react children to render.\n * @example\n * ```jsx\n * const contexts: ContextAndValue<any>[] = [\n *    [SomeContext, someValue],\n *    [UndoContext, undoContext]\n * ];\n * return <div>\n *   {composeContexts(contexts, navbarAndBody)}\n * </div>;\n * ```\n */\n\nconst composeContexts = (\n  contextAndValuePairs: ContextAndValue<any>[],\n  children: React.ReactNode\n) =>\n  contextAndValuePairs.reduce(\n    (acc: React.ReactNode, [Context, value]: ContextAndValue<any>) => {\n      return <Context.Provider value={value}>{acc}</Context.Provider>;\n    },\n    children\n  );\n\nexport default composeContexts;\n","import styled from \"styled-components\";\n\nconst OverflowScrollContainer = styled.div`\n  overflow: auto;\n`;\n\nexport default OverflowScrollContainer;\n","export const databaseTableNames = [\n  \"admin\",\n  \"places\",\n  \"amenities\",\n  \"entrances_or_exits\",\n  \"elevators\",\n  \"ramps\",\n  \"pedestrian_highways\",\n  \"conveying\",\n  \"toilets\",\n  \"buildings\",\n  \"master_routes\",\n  \"master_route_members\",\n  \"routes\",\n  \"route_members\",\n  \"stop_areas\",\n  \"stop_area_members\",\n  \"platforms\",\n  \"stop_positions\",\n  \"stations\",\n];\n\n/**\n * Filter layers from a mapbox-gl stylesheet.\n *\n * Keep only layers that have an `id` matching a 'osm-' prefix, and change sources to match the\n * table names from our OSM database.\n *\n * @param layers The layers to filter\n */\nexport function filterLayers(layers: mapboxgl.Layer[]): mapboxgl.Layer[] {\n  return layers\n    .filter((layer) => layer.id?.startsWith(\"osm-\"))\n    .map((layer) => {\n      // In Mapbox Studio, layers have a source layer reference that uses a random string ID like\n      // 'entrances_or_exits_saarbrueck-0vxz2q'. We need to replace that with the actual table name,\n      // for example 'entrances_or_exits'.\n      const source = databaseTableNames.find((tableName) =>\n        layer[\"source-layer\"]?.startsWith(tableName)\n      );\n\n      return {\n        ...layer,\n        source,\n        \"source-layer\": \"default\",\n      };\n    })\n    .filter((layer) => layer.source);\n}\n","import useSWR from \"swr\";\n\nconst fetcher = (input: RequestInfo, init?: RequestInit | undefined) =>\n  fetch(input, init).then((res) => res.json());\n\nfunction useMapStyle() {\n  const styleId = process.env.REACT_APP_MAPBOX_STYLE_ID;\n  const accessToken = process.env.REACT_APP_MAPBOX_ACCESS_TOKEN;\n  const accountId = process.env.REACT_APP_MAPBOX_ACCOUNT_ID;\n\n  const url = `https://api.mapbox.com/styles/v1/${accountId}/${styleId}?fresh=true&access_token=${accessToken}`;\n\n  const { data, error } = useSWR<mapboxgl.Style, { error: any }>(url, fetcher);\n\n  if (error) return { error };\n  if (!data) return { loading: true };\n\n  return { data };\n}\n\nexport default useMapStyle;\n","import mapboxgl from \"mapbox-gl\";\nimport * as React from \"react\";\nimport { useCallback, useLayoutEffect, useRef, useState } from \"react\";\nimport ReactMapGL, {\n  Layer,\n  MapContext,\n  MapRef,\n  Source,\n  ViewportProps,\n} from \"react-map-gl\";\nimport \"react-map-gl-geocoder/dist/mapbox-gl-geocoder.css\";\nimport { useHistory } from \"react-router\";\nimport useMeasure from \"react-use-measure\";\nimport OverflowScrollContainer from \"../OverflowScrollContainer\";\nimport { databaseTableNames, filterLayers } from \"./filterLayers\";\nimport useMapStyle from \"./useMapStyle\";\n\n// The following is required to stop \"npm build\" from transpiling mapbox code.\n// notice the exclamation point in the import.\n// @ts-ignore\n// eslint-disable-next-line import/no-webpack-loader-syntax, import/no-unresolved\nmapboxgl.workerClass = require(\"worker-loader!mapbox-gl/dist/mapbox-gl-csp-worker\").default;\n\ninterface IProps {\n  featureId?: string;\n  onSelectFeature: (_id: string) => void;\n  className?: string;\n  timestamp?: number;\n  visible?: boolean;\n  children?: React.ReactNode;\n}\n\nfunction ZoomToDataOnLoad() {\n  const mapContext = React.useContext(MapContext);\n\n  if (mapContext.map) {\n    // do something\n  }\n  return null;\n}\n\nexport default function MapView(props: IProps) {\n  const [containerRef, { width, height }] = useMeasure();\n  const mapRef = useRef<MapRef>(null);\n\n  // const { model: feature } = useMeteorData(\n  //   () => ({\n  //     subscriptions:\n  //       lastImportType && props.featureId\n  //         ? [[`${collectionName}.private`, '_id', props.featureId]]\n  //         : [],\n  //     fetchFunction: () => {\n  //       if (!lastImportType) {\n  //         return;\n  //       }\n  //       return collection?.findOne(props.featureId);\n  //     },\n  //   }),\n  //   [lastImportType, props.featureId]\n  // );\n\n  const [viewport, setViewport] = useState<\n    Partial<ViewportProps> & { width: number; height: number }\n  >({\n    width: 100,\n    height: 100,\n    latitude: 37.7577,\n    longitude: -122.4376,\n    zoom: 1,\n  });\n\n  // Pan to feature boundary if no single feature is selected and the source is loaded for the first time\n  // useEffect(() => {\n  //   if (feature) {\n  //     return;\n  //   }\n\n  //   const map = mapRef.current?.getMap() as Map;\n  //   if (!map) {\n  //     return;\n  //   }\n\n  //   map.once('idle', () => {\n  //     const features = map.querySourceFeatures('features');\n  //     const bounds = new LngLatBounds();\n  //     features\n  //       .filter(f => f.geometry?.coordinates)\n  //       .forEach(feature => bounds.extend(feature.geometry.coordinates));\n  //     if (bounds.isEmpty()) {\n  //       return;\n  //     }\n  //     const northWest = bounds.getNorthWest();\n  //     const southEast = bounds.getSouthEast();\n  //     if (!northWest || !southEast) {\n  //       return;\n  //     }\n  //     if (northWest.distanceTo(southEast) === 0) {\n  //       map.setCenter(bounds.getNorthEast());\n  //     } else {\n  //       map.fitBounds(bounds.toArray() as LngLatBoundsLike, { padding: 100, maxDuration: 0 });\n  //     }\n  //     map.once('idle', () => {\n  //       const newMapCenter = map.getCenter();\n  //       setViewport({ ...viewport, zoom: map.getZoom(), latitude: newMapCenter.lat, longitude: newMapCenter.lng });\n  //     });\n  //   });\n\n  //   // const newViewport = {\n  //   //   ...viewport,\n  //   //   latitude: feature?.geometry.coordinates?.[1],\n  //   //   longitude: feature?.geometry.coordinates?.[0],\n  //   //   zoom: Math.max(10, viewport.zoom || 10),\n  //   // };\n\n  //   // setViewport(newViewport);\n  // }, [mapRef.current]);\n\n  // Pan to single selected map feature, if it exists or changes\n  // useEffect(() => {\n  //   if (!feature || !feature.geometry) {\n  //     return;\n  //   }\n\n  //   const map = mapRef.current?.getMap() as Map;\n  //   if (!map) {\n  //     return;\n  //   }\n  //   const bounds = map.getBounds();\n  //   if (\n  //     viewport?.zoom &&\n  //     viewport?.zoom >= 10 &&\n  //     bounds &&\n  //     bounds.contains(feature.geometry.coordinates)\n  //   ) {\n  //     return;\n  //   }\n\n  //   const newViewport = {\n  //     ...viewport,\n  //     latitude: feature?.geometry.coordinates?.[1],\n  //     longitude: feature?.geometry.coordinates?.[0],\n  //     zoom: Math.max(10, viewport.zoom || 10),\n  //     pitch: 50,\n  //   };\n\n  //   setViewport(newViewport);\n  // }, [mapRef.current, feature?.geometry?.coordinates[0], feature?.geometry?.coordinates[1]]);\n\n  // Reset viewport when map size changes\n  useLayoutEffect(() => {\n    const newViewport = { ...viewport, width, height };\n    setViewport(newViewport);\n  }, [width, height]);\n\n  const history = useHistory();\n\n  // const featureLayer = useMemo(() => {\n  //   return generateSelectedFeatureLayer(props.featureId);\n  // }, [props.featureId]);\n\n  // const featureDetailsLayer = useMemo(() => {\n  //   return generateFeatureDetailsLayer(props.featureId);\n  // }, [props.featureId]);\n\n  // const unclusteredPointLabelLayer = useMemo(() => {\n  //   return generateUnclusteredPointLabelLayer(lastImportType, languageTagsStrings, props.featureId);\n  // }, [lastImportType, props.featureId]);\n\n  const handleMapClick = useCallback<(event: any) => void>(\n    (event) => {\n      const feature = event.features[0];\n      if (!feature) {\n        // Show source overview again if user just clicks/taps on the map\n        history.push(`/`);\n        return;\n      }\n      // if (feature?.layer.id === featureLayer.id) {\n      //   // Selected a single point\n      //   props.onSelectFeature(feature.properties._id || feature._id);\n      // }\n    },\n    [viewport]\n  );\n\n  const setViewportCallback = useCallback(\n    (viewState, interactionState) => {\n      // console.log('Setting viewport because of callback:', viewState, interactionState);\n      setViewport({ ...viewport, ...viewState });\n    },\n    [setViewport]\n  );\n\n  const onLoadCallback = useCallback(() => {\n    // const map = mapRef.current?.getMap();\n  }, [mapRef.current]);\n\n  const mapStyle = useMapStyle();\n  const layers = React.useMemo(\n    () => mapStyle.data?.layers && filterLayers(mapStyle.data?.layers),\n    [mapStyle]\n  );\n\n  return (\n    // Container needs to hide overflow because it's used for measurement.\n    // Without hiding overflowing content, it would adapt its own size to its overflowing content\n    // size on reducing its size while resizing the viewport, so it would only grow bigger, never\n    // shrink.\n    <OverflowScrollContainer\n      ref={containerRef}\n      className={props.className}\n      style={{\n        flex: 1,\n        display: props.visible === false ? \"none\" : \"block\",\n        position: \"relative\",\n      }}\n    >\n      <ReactMapGL\n        {...viewport}\n        mapboxApiAccessToken={process.env.REACT_APP_MAPBOX_ACCESS_TOKEN}\n        onViewportChange={setViewportCallback}\n        // interactiveLayerIds={[featureLayer?.id]}\n        onClick={handleMapClick}\n        onLoad={onLoadCallback}\n        mapStyle=\"mapbox://styles/mapbox/light-v10\"\n        ref={mapRef}\n      >\n        {databaseTableNames.map((name) => (\n          <Source\n            type=\"vector\"\n            tiles={[\n              `${process.env.REACT_APP_OSM_API_BACKEND_URL}/${name}.mvt?limit=10000&bbox={bbox-epsg-3857}&epsg=3857`,\n            ]}\n            id={name}\n            key={name}\n          />\n        ))}\n        {layers?.map((layer) => (\n          <Layer key={layer.id} {...(layer as any)} />\n        ))}\n        <ZoomToDataOnLoad />\n      </ReactMapGL>\n      {props.children}\n    </OverflowScrollContainer>\n  );\n}\n","import {\n  FocusStyleManager,\n  HotkeysProvider,\n  HotkeysTarget2,\n} from \"@blueprintjs/core\";\nimport * as React from \"react\";\nimport { useHistory, useLocation } from \"react-router\";\nimport styled from \"styled-components\";\nimport \"./App.css\";\nimport BlueprintDarkModeContainer from \"./core/BlueprintDarkModeContainer\";\nimport composeContexts, { ContextAndValue } from \"./core/composeContexts\";\nimport { useGlobalHotkeys } from \"./hooks/useGlobalHotkeys\";\nimport { Legend } from \"./Legend\";\nimport MapView from \"./map/MapView\";\nimport OverflowScrollContainer from \"./OverflowScrollContainer\";\n\nFocusStyleManager.onlyShowFocusOnTabs();\n\nconst AppBody = styled.div`\n  flex: 1;\n  overflow: hidden;\n  display: flex;\n  flex-direction: row;\n  align-items: stretch;\n`;\n\nfunction App() {\n  // const { viewMenuButton, viewOptions } = useViewOptionsButton();\n  // const isDarkMode = useDarkMode();\n  // The panel showing the Linked Data vocabulary graph\n\n  const contexts: ContextAndValue<any>[] = [\n    // [RDFGraphContext, rdfStore],\n  ];\n  const history = useHistory();\n  const location = useLocation();\n\n  const onSelectFeature = React.useCallback<(_id: string) => void>(\n    (_id) => {\n      const url = `/features/${_id}`;\n      history.push(`${url}${location.search}`);\n    },\n    [history, location]\n  );\n\n  const sidebar = (\n    <OverflowScrollContainer\n      style={{ width: \"400px\", padding: \"1rem\", margin: \"0\" }}\n    >\n      <h1>Miki: Erforsche deinen Kiez</h1>\n      <Legend />\n    </OverflowScrollContainer>\n  );\n\n  const mapView = (\n    <MapView\n      featureId={undefined}\n      onSelectFeature={onSelectFeature}\n      visible={true}\n    />\n  );\n\n  const navbarAndBody = (\n    <>\n      <AppBody>\n        {/* {sidebar} */}\n        {mapView}\n      </AppBody>\n    </>\n  );\n\n  const hotkeys = useGlobalHotkeys();\n  return (\n    <HotkeysProvider>\n      <HotkeysTarget2 hotkeys={hotkeys}>\n        {({ handleKeyDown, handleKeyUp }) => (\n          <BlueprintDarkModeContainer\n            style={{\n              height: \"100%\",\n              display: \"flex\",\n              flexDirection: \"column\",\n            }}\n            onKeyDown={handleKeyDown}\n            onKeyUp={handleKeyUp}\n          >\n            {composeContexts(contexts, navbarAndBody)}\n          </BlueprintDarkModeContainer>\n        )}\n      </HotkeysTarget2>\n    </HotkeysProvider>\n  );\n}\n\nexport default App;\n","import React from \"react\";\n\nexport function useGlobalHotkeys() {\n  return React.useMemo(\n    () => [\n      {\n        combo: \"mod+z\",\n        global: true,\n        label: \"Undo\",\n        onKeyDown: () => {\n          alert(\"!!\");\n        },\n        allowInInput: false,\n        preventDefault: true,\n      },\n      {\n        global: true,\n        combo: \"mod+shift+z\",\n        label: \"Redo\",\n        onKeyDown: () => {\n          alert(\"!!\");\n        },\n        allowInInput: false,\n        preventDefault: true,\n      },\n    ],\n    []\n  );\n}\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import dotenv from \"dotenv\";\nimport { enableAllPlugins, enablePatches } from \"immer\";\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { BrowserRouter } from \"react-router-dom\";\nimport App from \"./components/App\";\nimport \"./index.css\";\nimport reportWebVitals from \"./reportWebVitals\";\n\ndotenv.config();\nenableAllPlugins();\nenablePatches();\n\nReactDOM.render(\n  <React.StrictMode>\n    <BrowserRouter>\n      <App />\n    </BrowserRouter>\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}